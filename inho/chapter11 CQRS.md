# Chapter 11 CQRS

# 11.1 단일 모델의 단점

- 주문 내역을 조회해서 사용자의 화면에 주문 / 제품 / 주문한 사용자의 정보를 보여준다
    1. `Order` ENTITY 를 통해 주문정보 조회
    2. `Product` ENTITY 를 통해 제품정보 조회
    3. `Member` ENTITY 를 통해 주문한 사용자 정보 조회

![IMG_9650.jpg](Chapter%2011%20CQRS%20727c2085197141e1a319c5253372e549/IMG_9650.jpg)

[출처: 도메인 주도개발 시작하기 / 최범균]

- 시스템의 상태변경과 조회할 때 단일모델을 사용하는 것이 원인이다. → 모델 분리

# 11.2 CQRS

- **C**ommand **Q**uery **R**esponsibility **S**egregation (명령과 조회의 모델(책임) 분리)
- 상태를 변경하는 명령(**C**ommand)을 위한 모델과 상태를 조회하는 명령(**C**ommand)을 위한 모델을 분리한다.
- 복잡한 도메인에 적합하다.

**시스템이 제공하는 기능의 대분류**

| 기능 | 특징 | 예시 |
| --- | --- | --- |
| 상태를 변경하는 기능 | 주로 한 애그리거트의 상태를 변경한다. | 새로운 주문을 등록 |
|  |  | 배송지 변경 |
|  |  | 회원의 암호 변경 |
| 상태를 조회하는 기능 | 두 개 이상의 애그리거트가 필요하다. | 주문 상세내역 보기 |
|  |  | 게시글 목록보기 |
|  |  | 회원 조회 |
|  |  | 판매 통계 조회 |

![IMG_9651.jpg](Chapter%2011%20CQRS%20727c2085197141e1a319c5253372e549/IMG_9651.jpg)

[출처: 도메인 주도개발 시작하기 / 최범균]

| 기능 | 모델 | 구현기술 |
| --- | --- | --- |
| 상태를 조회하는 기능 | 조회(Query) 모델 | MyBatis  |
| 상태를 변경하는 기능 | 명령(Command) 모델 | JPA |

![IMG_9694.jpg](Chapter%2011%20CQRS%20727c2085197141e1a319c5253372e549/IMG_9694.jpg)

[출처: 도메인 주도개발 시작하기 / 최범균]

- 조회 모델은 응용 서비스가 존재하지 않는다. → 단순 조회 → 응용 로직이 복잡하지 않음
- 상태 변경을 위한 명령 모델은 객체를 기반으로 한 도메인 모델을 이용해서 구현한다. → 상태변경 집중 → Layered Architecture 적용

![IMG_9695.jpg](Chapter%2011%20CQRS%20727c2085197141e1a319c5253372e549/IMG_9695.jpg)

[출처: 도메인 주도개발 시작하기 / 최범균]

- 구현 기술을 다르게 사용하거나 물리적으로 서로 다른 DBMS 를 사용하도록 구현할 수 있다.
    - 조회기능은 MyBatis, 상태변경기능은 JPA
    - 조회 데이터는 조회시 성능이 좋은 NoSQL, 상태변경이 필요한 데이터는 트랜잭션을 지원하는 RDBMS
        - 데이터 동기화는 이벤트를 활용

![IMG_9696.jpg](Chapter%2011%20CQRS%20727c2085197141e1a319c5253372e549/IMG_9696.jpg)

[출처: 도메인 주도개발 시작하기 / 최범균]

### 11.2.1 웹과 CQRS

- 조회 기능이 주로 실행되는 기능일 때, 조회 성능을 높이기 위해서 다양한 방법을 사용하여 최적화 하는 것은 CQRS 를 적용하는 것과 비슷한 효과를 낸다.
- 조회 성능을 높이기 위해 별도의 처리를 하고 있다면 모델분리를 고민해보자.
    - 조회 성능을 높이기 위한 작업이 변경하는 기능에 영항을 주거나 모델을 복잡하게 만드는 것을 방지할 수 있다.

### 11.2.2 CQRS 장단점

![IMG_9697.jpg](Chapter%2011%20CQRS%20727c2085197141e1a319c5253372e549/IMG_9697.jpg)

[출처: 도메인 주도개발 시작하기 / 최범균]

| 장점 | 단점 |
| --- | --- |
| 각각의 도메인 모델에 집중할 수 있다. | 별도의 모델을 분리하면서 구현해야 할 코드가 많아진다.  |
| 조회 기능의 성능을 향상시키는 데 유리하다. | 더 많은 구현기술에 대한 고민과 적용이 필요하다. |
| 모델의 복잡도를 분산시킬 수 있다. |  |
